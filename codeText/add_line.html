<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style>

</style>

<body>

</body>
<script>
    // 1. A + B 问题
    // 中文English
    // 给出两个整数 aa 和 bb , 求他们的和。

    // 样例
    // 样例 1:

    // 输入: a = 1, b = 2
    // 输出: 3
    // 样例解释: 返回a+b的结果.
    // 样例 2:

    // 输入: a = -1, b = 1
    // 输出: 0
    // 样例解释: 返回a+b的结果.
    // 挑战
    // 显然你可以直接 return a + b，但是你是否可以挑战一下不这样做？（不使用++等算数运算符）


    const aplusb = function (a, b) {
        // write your code here 
        console.log(a.toString(2) ^ b.toString(2));

    }


    var addBinary = function (a, b) {
        //将计算位左对齐
        var [a2Arr, b2Arr] = [a.toString(2).split("").reverse(), b.toString(2).split("").reverse()];
        //定义进位 carry 
        console.log(a2Arr, b2Arr);

        var [lena, lenb, carry, result] = [a.length, b.length, 0, []];
        //取得较长数组进行遍历，以确保完全迭代
        var lenMax = Math.max(lena, lenb);
        for (var i = 0; i < lenMax; i++) {
            //每一项的值为两数组对应项数字和加上进位值
            //括号前面的加号代表类型转换，转换不了就置0
            var itemSum = +(a2Arr[i] || 0) + +(b2Arr[i] || 0) + carry;
            //根据每项值来定义结果位和进位
            if (itemSum == 0) {
                result[i] = 0;
                carry = 0;
            } else if (itemSum == 1) {
                result[i] = 1;
                carry = 0;
            } else if (itemSum == 2) {
                result[i] = 0;
                carry = 1;
            } else {
                result[i] = 1;
                carry = 1;
            }
        }
        //若最高位发生进位，插入1
        if (carry == 1) result.push(1);
        //反序并连接为字符串
        console.log(result);

        return result.reverse().join("");
    };
    console.log(addBinary(2, 3));
</script>

</html>